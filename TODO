##                               -*- Mode: org; indent-tabs-mode: nil -*-
## TODO List
## $Id: TODO,v 1.7 2008/04/21 10:25:56 mina86 Exp $
##

Liczba w nawiasach kwadratowych oznacza piorytet -- [0] najwy¿szy, [5]
najni¿szy.  [DONE] oznacza, i¿ rzecz zosta³a zroiona.

* [DONE] Obs³uga \<NL>

  Lexer powinien traktowaæ backslash jako specialny znak.  <del>Je¿eli
  nastêpnym znakiem po backslashu bêdzie drugi backslash lexer
  powinien zwróciæ pojedynczy token okre¶laj±cy znak backslash.</del>
  Je¿eli nastêpnym znakiem bêdzie znak przej¶cia do nowej linii lexer
  winien traktowaæ sekwencjê tych dwóch znaków jako bia³y znak.
  <del>Inne sekwencje powinny (na razie) zwracaæ oba znaki,
  w przysz³o¶ci mog± mieæ inne znaczenie.</del> Inne znaki powinny byæ
  zwracane "as is".

* [0] Wbudowane funkcje

  Nale¿y stworzyæ serjê klas reprezentuj±cych wbudowane funkcje, czyli
  to co obecnie jest w functions.hpp/cpp nale¿y przerobiæ na klasy
  dziedzicz±ce po BuiltInFunction.  Jedyne co metoda BuiltInFunction
  bêdzie robiæ to nadpisywaæ metodê free(), tak aby nie robi³a ona
  nic.  Wynika to faktu, i¿ obiekty te powinny byæ singletonami,
  tzn. udostêpniaæ statyczn± metodê get(), która wygl±daæ bêdzie mniej
  wiêcej tak:

    FooFunction *FooFunction::get() {
        static FooFunction foo;
        return &foo;
    }

  Pewnie dobrze by by³o, gdyby klasa BuiltInFunction udostêpnia³a
  ponadto konstruktor przyjmuj±cy minimaln± i maksymaln± liczbê
  argumentów, jak± funkcja przyjmuje oraz napisywa³a metode
  argumentsCountOK() tak, aby porównywa³a liczbê argumentów
  z dopuszczalnym przedzia³em (wówczas ka¿da klasa z osobna nie bêdzie
  musia³a tago robiæ (choæ z drugiej strony bêdzie musia³a wo³aæ
  konstruktor klasy bazowej, ale to chyba bardziej czytelne
  i zwiêz³e)).

** [4] Nowe funkcje

   Nale¿y ponadto dodaæ kolejne funkcje takie jak floor(), celi(),
   round(), gcd() (greatest common divisor), lcm() (least common
   multiple) i co tam jeszcze przyjdzie do g³owy.

** [4] Nowe operatory

   Zawsze mo¿na te¿ wymy¶laæ nowe operatory, np.:
   - expr % expr -- dzielenie modulo
   - expr ! -- silnia (nale¿y zwróciæ uwagê, czy u¿ycie '!' nie
               spowoduje konfliktów z wyra¿eniami logicznymi
   - ( expr expr ) -- dwumian Newtona

* [1] Dodanie obs³ugi linii poleceñ

** [1] -v - wypisywanie wyników instrukcji

   W chwili obecnej, za ka¿dym razem, gdy jest wykonana instrukcja
   (niezakoñczona ¶rednikiem) jej wynik wypisywany jest na standardowe
   wyj¶cie.  W wersji finalnej powinno tak siê dziaæ tylko, gdy dodany
   zostanie prze³±cznik -v.

   Zrealizowaæ to mo¿na do¶æ prosto tworz±c klasê dziedzicz±c± po
   Enviroment nazwan± SilentEnviroment, która bêdzie nadpisywaæ metodê
   instruction(), tak aby tak nic nie robi³a.  Wówczas zale¿nie od
   tego czy dany prze³±cznik zosta³ podany czy nie funkcja main()
   bêdzie alo tworzyæ obiekt Enviroment albo SilentEnviroment.  Mo¿na
   te¿ zrobiæ na odwrót, tzn. Enviroment nie bêdzie wypisywaæ
   i stworzyæ klasê VerboseEnviroment.

** [1] -q - wypisywanie zmiennych po zakoñczeniu

   Obecnie po napotkaniu koñca pliku program wypisuje warto¶ci
   wszystkich zmiennych globalnych.  Prze³±cznik -q powinien takie
   zachowanie wy³±czaæ.

** [1] -h - wypisywanie pomocy

   Chyba nie trzeba komentowaæ, powinnien siê tu znale¿æ opis
   prze³±czników oraz sk³adni.

** [2] -l - wypisywanie wbudowanych funkcji

   Prze³±cznik ten powinien spowodowaæ, ¿e program wypiszê listê
   wbudowanych funkcji i zakoñczy dzia³anie.

** [2] -L - wypisanie sta³ych

   Prze³±cznik ten powinien spowodowaæ, ¿e program wypiszê listê
   sta³ych (wraz z warto¶cami) i zakoñczy dzia³anie.

* [0] Obs³uga wyj±tków rzucanych przez Expression::execute()

  Obecnie wyj±tki rzucane przez Expression::execute() nie s±
  obs³ugiwane.  Nale¿y dodaæ t± obs³ugê do pliku parser.y.  Je¿eli
  wyj±tek zostanie rzucony powinien zostaæ wypisany komunikat.  Stan
  ¶rodowiska bêdzie w chwili obecnej niezdefiniowany (tzn. nadal
  wszystko ma dzia³aæ dobrze, ale to czy niektóre efekty uboczne
  wyra¿enia, które rzuci³o wyj±tek zosta³y wykonanie czy nie nie jest
  okre¶lone).

** [0] B³êdne wo³ania funkcji powinny rzucaæ wyj±tek

   Obecnie, FunctionExpression::exception() zamiast rzucaæ wyj±tek,
   gdy jest b³êdna liczba argumentów lub nieistniej±ca funkcja
   wypisuje komunikat.  Nalezy to zmieniæ.

* [0] Definiowanie funkcji

  Nale¿y dodaæ mo¿liwo¶æ definiowania funkcji.  Ogólna sk³adnia bêdzie
  wygl±daæ jako¶ tak:

    define_instruction: DEFINE ID '(' formal_arguments ')' = assignment_expr
    formal_arguments: /* empty */
                    | non_empty_formal_arguments
    non_empty_formal_arguments: ID
                              | non_empty_formal_arguments ',' ID

  formal_arguments i non_empty_formal_arguments winny budowaæ
  std::vector<std::string> (czyli UserFunction::Names),
  a define_instruction tworzyæ nowy obiekt UserFunction.

* [1] Operator ?: i operatory logiczne

  Nale¿y dodaæ obs³ugê oepratora ?: oraz operatorów logicznych.
  Poprzednio pisa³em, aby zastosowaæ odrêbn± klasê wyra¿eñ
  BooleanExpresson, ale chyba mo¿na to wszystko za³atwiæ jako zwyk³e
  Expression--wówczas bez problemu bêdzie mo¿na definiowaæ funkcje
  które zwracaj± warto¶ci true/false.

  Proponujê nastêpuj±ca gramatykê:

  cond_expr: logic_or_expr
           | logic_or_expr '?' expr ':' cond_expr
  logic_or_expr: logic_and_expr
               | logic_or_expr "||" logic_and_expr
  logic_and_expr: cmp_expr
                | logic_and_expr "&&" cmp_expr
  cmp_expr: rel_expr
          | cmp_expr cmp_op rel_expr
  rel_expr: additive_expr
          | rel_expr rel_op additive_expr
  cmp_op: "==" | "!="
  rel_op: "<=" | ">=" | '<' | '>'

  W assignment_expr w ostatniej alternatywie bêdzie trzeba oczywi¶cie
  zmieniæ additive_expr na cond_expr.

  Operatory && i || nie bêd± rzecz jasna wyliczaæ prawego argumentu,
  je¿eli wynik bêdzie mo¿na wywnioskowaæ z lewego.

  Operatory logiczne bêd± zwracaæ 0 w przypadku fa³szu i 1 w przypadku
  prawdy.  Co wiêcej, wyra¿enie bêdzie uznawane, ¿e ma warto¶æ
  prawdziw± je¿eli bêdzie ona ró¿na od 0.  Co¶ takiego powinno
  zadzia³aæ, gdy¿ w typie double mo¿na bez przeszkód przechowywaæ
  warto¶æ zero.

** [3] Porównywanie liczb z pewn± dok³adno¶ci± ("Fuzzy Comparison")

   Proponujê dodaæ jeszcze nastêpuj±ce operatory:

    Operator | Typ    | Przyk³ad | Znaczenie
     =~      | cmp_op | a =~ b   | abs(a - b) <= p
     !~      | cmp_op | a !~ b   | abs(a - b) >  p
     <~      | rel_op | a <~ b   | a <  b - p
     <=~     | rel_op | a <=~ b  | a <= b + p
     >~      | rel_op | a >~ b   | a - p > b
     >=~     | rel_op | a >=~ b  | a + p >= b

   Gdzie p bêdzie z góry ustalon± sta³±.

*** [5] Parametr wywo³ania -p

    Przy wywo³aniu programu z parametrem -p i liczb± rzeczywist± mo¿na
    ustaliæ parametr p, z którym "Fuzzy Comparison" jest wykonywane.

* [DONE] Operator ,

  Warto te¿ dodaæ operator ',', gdy¿ bêdzie on szczególnie przydatny
  przy definiowaniu funkcji, np.:

  define foo(x, y, z) tmp = dlugi_i_zlozony_ciag_boliczen, \
      tmp * tmp

  gdy¿:

  define foo(x, y, z) (tmp = dlugi_i_zlozony_ciag_boliczen) * tmp

  ma niezdefiniowan± kolejno¶æ wykonywania wyra¿eñ, a

  define foo(x, y, z) = dlugi_i_zlozony_ciag_boliczen * \
      dlugi_i_zlozony_ciag_boliczen

  dwa razy wylicza co¶ bardzo z³o¿onego (tak, wiem ¿e mamy operacje
  potêgowania, ale to tylko przyk³ad).

** [DONE] Magiczne traktowanie przecinka przez lexer

   Lexer móg³by traktowaæ przecinek w magiczny sposób, tzn. ignorowaæ
   znak przej¶cia do nowej linii je¿eli wystêpuje on zaraz za
   przecinkiem albo wrêcz ignorowaæ wszystkie bia³e znaki, a w tym
   i znaki przej¶cia do nowej linii, wystêpuj±ce za przecinkiem,
   a przed czymkolwiek innym, wówczas definiowanie funkcji by³oby
   jeszcze prostrze:

   define foo(x, y, z) = wyrazenie,
      wyrazenie,
      wyrazenie,
      wyrazenie,
      wyrazenie

   bez konieczno¶ci koñczenia ka¿dej linijki backslashem.

* [DONE] Poprawienie kodu i zmiana std::string* na std::string

  Poniewa¿ bison by³ pierwotnie pisany dla C to niezbyt sobie radzi
  z czym¶ takim jak destruktory.  Z tego powodu je¿eli chcemy wywo³aæ
  w nim destruktor to trzeba korzytaæ ze wska¼ników i obiektów
  tworzonych na stercie.  Tak te¿ jest z std::string.  Jednak, pisz±c
  na szybko, wyra¿enia w expression.hpp, które przyjmuj± nazwê
  zmiennej/funkcji te¿ operuj± na wska¼nikach do std::string, co jest
  raczej niedobre.  Dlatego trzeba wyczy¶ciæ kod, tak aby obiekty
  w expression.hpp trzyma³y bezpo¶rednio obiekty std::string, a nie
  wska¼niki do nich.  Nale¿y wówczas zwróciæ uwagê na odpowiednie
  zmodyfikowanie parser.y w ten sposób, aby wska¼niki nie by³y
  zerowane, gdy¿ wówczas destruktory bêd± musia³y byæ wywo³ywane
  (obecnie w parser.y widaæ instrukcje typu $1 = 0 czy $1.name = 0,
  gdy¿ imituj± one zachowanie sprytnych wska¼ników;  w przypadku
  wyra¿eñ (obiektów Expression) zachowanie takie jest nadal konieczne,
  lecz je¿eli obiekty dziedzicz±ce po Expression bêd± trzyma³y w³asn±
  kopiê std::string to w odniesieniu do ci±gów znaków zachowanie takie
  mo¿e byæ ju¿ b³êdne).

* [2] Uzupe³niæ dokumentacjê

  Na koniec nale¿y tak¿e uzupe³niæ dokumentacjê w plikach ¼ród³owych.
