



##                               -*- Mode: org; indent-tabs-mode: nil -*-
## TODO List
## $Id: TODO,v 1.10 2008/05/22 07:59:39 mina86 Exp $
##

Liczba w nawiasach kwadratowych oznacza piorytet -- [0] najwy�szy, [5]
najni�szy.  [DONE] oznacza, i� rzecz zosta�a zroiona.

* [DONE] Obs�uga \<NL>

  Lexer powinien traktowa� backslash jako specialny znak.  <del>Je�eli
  nast�pnym znakiem po backslashu b�dzie drugi backslash lexer
  powinien zwr�ci� pojedynczy token okre�laj�cy znak backslash.</del>
  Je�eli nast�pnym znakiem b�dzie znak przej�cia do nowej linii lexer
  winien traktowa� sekwencj� tych dw�ch znak�w jako bia�y znak.
  <del>Inne sekwencje powinny (na razie) zwraca� oba znaki,
  w przysz�o�ci mog� mie� inne znaczenie.</del> Inne znaki powinny by�
  zwracane "as is".

* [DONE] Wbudowane funkcje

  Nale�y stworzy� serj� klas reprezentuj�cych wbudowane funkcje, czyli
  to co obecnie jest w functions.hpp/cpp nale�y przerobi� na klasy
  dziedzicz�ce po BuiltInFunction.  Jedyne co metoda BuiltInFunction
  b�dzie robi� to nadpisywa� metod� free(), tak aby nie robi�a ona
  nic.  Wynika to faktu, i� obiekty te powinny by� singletonami,
  tzn. udost�pnia� statyczn� metod� get(), kt�ra wygl�da� b�dzie mniej
  wi�cej tak:

    FooFunction *FooFunction::get() {
        static FooFunction foo;
        return &foo;
    }

  Pewnie dobrze by by�o, gdyby klasa BuiltInFunction udost�pnia�a
  ponadto konstruktor przyjmuj�cy minimaln� i maksymaln� liczb�
  argument�w, jak� funkcja przyjmuje oraz napisywa�a metode
  argumentsCountOK() tak, aby por�wnywa�a liczb� argument�w
  z dopuszczalnym przedzia�em (w�wczas ka�da klasa z osobna nie b�dzie
  musia�a tago robi� (cho� z drugiej strony b�dzie musia�a wo�a�
  konstruktor klasy bazowej, ale to chyba bardziej czytelne
  i zwi�z�e)).

** [4] Nowe funkcje

   Nale�y ponadto doda� kolejne funkcje takie jak floor(), celi(),
   round(), gcd() (greatest common divisor), lcm() (least common
   multiple) i co tam jeszcze przyjdzie do g�owy.

** [4] Nowe operatory

   Zawsze mo�na te� wymy�la� nowe operatory, np.:
   - expr % expr -- dzielenie modulo
   - expr ! -- silnia (nale�y zwr�ci� uwag�, czy u�ycie '!' nie
               spowoduje konflikt�w z wyra�eniami logicznymi
   - ( expr expr ) -- dwumian Newtona

* [DONE] Dodanie obs�ugi linii polece�

** [DONE] -v - wypisywanie wynik�w instrukcji

   W chwili obecnej, za ka�dym razem, gdy jest wykonana instrukcja
   (niezako�czona �rednikiem) jej wynik wypisywany jest na standardowe
   wyj�cie.  W wersji finalnej powinno tak si� dzia� tylko, gdy dodany
   zostanie prze��cznik -v.

   Zrealizowa� to mo�na do�� prosto tworz�c klas� dziedzicz�c� po
   Enviroment nazwan� SilentEnviroment, kt�ra b�dzie nadpisywa� metod�
   instruction(), tak aby tak nic nie robi�a.  W�wczas zale�nie od
   tego czy dany prze��cznik zosta� podany czy nie funkcja main()
   b�dzie alo tworzy� obiekt Enviroment albo SilentEnviroment.  Mo�na
   te� zrobi� na odwr�t, tzn. Enviroment nie b�dzie wypisywa�
   i stworzy� klas� VerboseEnviroment.

** [DONE] -q - wypisywanie zmiennych po zako�czeniu

   Obecnie po napotkaniu ko�ca pliku program wypisuje warto�ci
   wszystkich zmiennych globalnych.  Prze��cznik -q powinien takie
   zachowanie wy��cza�.

** [DONE] -h - wypisywanie pomocy

   Chyba nie trzeba komentowa�, powinnien si� tu znale�� opis
   prze��cznik�w oraz sk�adni.

** [DONE] -l - wypisywanie wbudowanych funkcji

   Prze��cznik ten powinien spowodowa�, �e program wypisz� list�
   wbudowanych funkcji i zako�czy dzia�anie.

** [DONE] -L - wypisanie sta�ych

   Prze��cznik ten powinien spowodowa�, �e program wypisz� list�
   sta�ych (wraz z warto�cami) i zako�czy dzia�anie.

* [DONE} Obs�uga wyj�tk�w rzucanych przez Expression::execute()

  Obecnie wyj�tki rzucane przez Expression::execute() nie s�
  obs�ugiwane.  Nale�y doda� t� obs�ug� do pliku parser.y.  Je�eli
  wyj�tek zostanie rzucony powinien zosta� wypisany komunikat.  Stan
  �rodowiska b�dzie w chwili obecnej niezdefiniowany (tzn. nadal
  wszystko ma dzia�a� dobrze, ale to czy niekt�re efekty uboczne
  wyra�enia, kt�re rzuci�o wyj�tek zosta�y wykonanie czy nie nie jest
  okre�lone).

** [DONE] B��dne wo�ania funkcji powinny rzuca� wyj�tek

   Obecnie, FunctionExpression::execute() zamiast rzuca� wyj�tek,
   gdy jest b��dna liczba argument�w lub nieistniej�ca funkcja
   wypisuje komunikat.  Nalezy to zmieni�.

* [DONE] Definiowanie funkcji

  Nale�y doda� mo�liwo�� definiowania funkcji.  Og�lna sk�adnia b�dzie
  wygl�da� jako� tak:

    define_instruction: DEFINE ID '(' formal_arguments ')' = assignment_expr
    formal_arguments: /* empty */
                    | non_empty_formal_arguments
    non_empty_formal_arguments: ID
                              | non_empty_formal_arguments ',' ID

  formal_arguments i non_empty_formal_arguments winny budowa�
  std::vector<std::string> (czyli UserFunction::Names),
  a define_instruction tworzy� nowy obiekt UserFunction.

* [DONE] Operator ?: i operatory logiczne

  Nale�y doda� obs�ug� oepratora ?: oraz operator�w logicznych.
  Poprzednio pisa�em, aby zastosowa� odr�bn� klas� wyra�e�
  BooleanExpresson, ale chyba mo�na to wszystko za�atwi� jako zwyk�e
  Expression--w�wczas bez problemu b�dzie mo�na definiowa� funkcje
  kt�re zwracaj� warto�ci true/false.

  Proponuj� nast�puj�ca gramatyk�:

  cond_expr: logic_or_expr
           | logic_or_expr '?' expr ':' cond_expr
  logic_or_expr: logic_and_expr
               | logic_or_expr "||" logic_and_expr
  logic_and_expr: cmp_expr
                | logic_and_expr "&&" cmp_expr
  cmp_expr: rel_expr
          | cmp_expr cmp_op rel_expr
  rel_expr: additive_expr
          | rel_expr rel_op additive_expr
  cmp_op: "==" | "!="
  rel_op: "<=" | ">=" | '<' | '>'

  W assignment_expr w ostatniej alternatywie b�dzie trzeba oczywi�cie
  zmieni� additive_expr na cond_expr.

  Operatory && i || nie b�d� rzecz jasna wylicza� prawego argumentu,
  je�eli wynik b�dzie mo�na wywnioskowa� z lewego.

  Operatory logiczne b�d� zwraca� 0 w przypadku fa�szu i 1 w przypadku
  prawdy.  Co wi�cej, wyra�enie b�dzie uznawane, �e ma warto��
  prawdziw� je�eli b�dzie ona r��na od 0.  Co� takiego powinno
  zadzia�a�, gdy� w typie double mo�na bez przeszk�d przechowywa�
  warto�� zero.

* [3] Por�wnywanie liczb z pewn� dok�adno�ci� ("Fuzzy Comparison")

  Proponuj� doda� jeszcze nast�puj�ce operatory:

    Operator | Typ    | Przyk�ad | Znaczenie
     =~      | cmp_op | a =~ b   | abs(a - b) <= p
     !~      | cmp_op | a !~ b   | abs(a - b) >  p
     <~      | rel_op | a <~ b   | a <  b - p
     <=~     | rel_op | a <=~ b  | a <= b + p
     >~      | rel_op | a >~ b   | a - p > b
     >=~     | rel_op | a >=~ b  | a + p >= b

  Gdzie p b�dzie z g�ry ustalon� sta��.

** [5] Parametr wywo�ania -p

   Przy wywo�aniu programu z parametrem -p i liczb� rzeczywist�
   mo�na ustali� parametr p, z kt�rym "Fuzzy Comparison" jest
   wykonywane.

* [DONE] Operator ,

  Warto te� doda� operator ',', gdy� b�dzie on szczeg�lnie przydatny
  przy definiowaniu funkcji, np.:

  define foo(x, y, z) tmp = dlugi_i_zlozony_ciag_boliczen, \
      tmp * tmp

  gdy�:

  define foo(x, y, z) (tmp = dlugi_i_zlozony_ciag_boliczen) * tmp

  ma niezdefiniowan� kolejno�� wykonywania wyra�e�, a

  define foo(x, y, z) = dlugi_i_zlozony_ciag_boliczen * \
      dlugi_i_zlozony_ciag_boliczen

  dwa razy wylicza co� bardzo z�o�onego (tak, wiem �e mamy operacje
  pot�gowania, ale to tylko przyk�ad).

** [DONE] Magiczne traktowanie przecinka przez lexer

   Lexer m�g�by traktowa� przecinek w magiczny spos�b, tzn. ignorowa�
   znak przej�cia do nowej linii je�eli wyst�puje on zaraz za
   przecinkiem albo wr�cz ignorowa� wszystkie bia�e znaki, a w tym
   i znaki przej�cia do nowej linii, wyst�puj�ce za przecinkiem,
   a przed czymkolwiek innym, w�wczas definiowanie funkcji by�oby
   jeszcze prostrze:

   define foo(x, y, z) = wyrazenie,
      wyrazenie,
      wyrazenie,
      wyrazenie,
      wyrazenie

   bez konieczno�ci ko�czenia ka�dej linijki backslashem.

* [DONE] Poprawienie kodu i zmiana std::string* na std::string

  Poniewa� bison by� pierwotnie pisany dla C to niezbyt sobie radzi
  z czym� takim jak destruktory.  Z tego powodu je�eli chcemy wywo�a�
  w nim destruktor to trzeba korzyta� ze wska�nik�w i obiekt�w
  tworzonych na stercie.  Tak te� jest z std::string.  Jednak, pisz�c
  na szybko, wyra�enia w expression.hpp, kt�re przyjmuj� nazw�
  zmiennej/funkcji te� operuj� na wska�nikach do std::string, co jest
  raczej niedobre.  Dlatego trzeba wyczy�ci� kod, tak aby obiekty
  w expression.hpp trzyma�y bezpo�rednio obiekty std::string, a nie
  wska�niki do nich.  Nale�y w�wczas zwr�ci� uwag� na odpowiednie
  zmodyfikowanie parser.y w ten spos�b, aby wska�niki nie by�y
  zerowane, gdy� w�wczas destruktory b�d� musia�y by� wywo�ywane
  (obecnie w parser.y wida� instrukcje typu $1 = 0 czy $1.name = 0,
  gdy� imituj� one zachowanie sprytnych wska�nik�w;  w przypadku
  wyra�e� (obiekt�w Expression) zachowanie takie jest nadal konieczne,
  lecz je�eli obiekty dziedzicz�ce po Expression b�d� trzyma�y w�asn�
  kopi� std::string to w odniesieniu do ci�g�w znak�w zachowanie takie
  mo�e by� ju� b��dne).

* [DONE] Uzupe�ni� dokumentacj�

  Na koniec nale�y tak�e uzupe�ni� dokumentacj� w plikach �r�d�owych.
